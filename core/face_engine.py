# core/face_engine.py
"""
Модуль анализа и распознавания лиц
Автор: Студент 4 курса ОмГУ им. Ф.М. Достоевского
ВКР: Автоматизированная система распознавания лиц

Описание:
Движок анализа лиц является ядром системы биометрической идентификации.
Инкапсулирует алгоритмы компьютерного зрения и машинного обучения для:
- Детекции лиц на изображениях и видеопотоке
- Извлечения биометрических признаков (векторов признаков лица)
- Сравнения и идентификации лиц
- Визуализации результатов распознавания

Технологическая основа:
- face_recognition: Библиотека на основе dlib для распознавания лиц
- OpenCV: Обработка изображений и компьютерное зрение
- NumPy: Математические операции с векторами признаков

Алгоритмическая основа:
- HOG (гистограмма направленных градиентов) для детекции лиц
- Сверточная нейронная сеть (CNN) для извлечения признаков
- Евклидово расстояние для сравнения биометрических отпечатков
"""

import cv2  # Библиотека компьютерного зрения для обработки изображений и видео
import face_recognition  # Библиотека для распознавания лиц на основе dlib
import numpy as np  # Библиотека для работы с многомерными массивами и математическими операциями
from config.settings import FACE_RECOGNITION_CONFIDENCE_THRESHOLD


class FaceAnalysisEngine:
    """
    Движок анализа и распознавания лиц
    
    Класс инкапсулирует всю логику работы с технологиями распознавания лиц:
    - Создание биометрических отпечатков (кодировок) лиц из фотографий
    - Сравнение лиц на видеопотоке с зарегистрированными пользователями  
    - Визуализация результатов распознавания на видеокадрах
    
    Использует библиотеку face_recognition, которая построена на основе dlib
    и использует глубокие нейронные сети для извлечения признаков лиц.
    Каждое лицо представляется 128-мерным вектором признаков, который
    служит уникальным биометрическим отпечатком.
    
    Архитектурные особенности:
    - Хранение биометрических отпечатков в памяти для быстрого доступа
    - Векторизованные операции сравнения для производительности
    - Настраиваемые пороги уверенности для балансировки точности и полноты
    """
    
    def __init__(self):
        """
        Инициализация движка распознавания лиц
        
        Создает пустые списки для хранения:
        - registered_user_encodings: биометрических отпечатков зарегистрированных пользователей
        - registered_user_identifiers: соответствующих ID пользователей
        
        Эти списки синхронизированы по индексам - encoding[i] соответствует user_id[i]
        """
        self.registered_user_encodings = []  # Список массивов numpy с кодировками лиц (128-мерные векторы)
        self.registered_user_identifiers = []  # Список строковых ID пользователей
    
    def load_facial_encodings(self, encodings, user_ids):
        """
        Загрузка биометрических отпечатков лиц в память
        
        Инициализирует движок базой зарегистрированных пользователей для
        последующего распознавания. Биометрические отпечатки загружаются
        в оперативную память для обеспечения высокой скорости сравнения
        в режиме реального времени.
        
        Аргументы:
            encodings (list): Список массивов numpy размерности (128,) содержащих
                            биометрические признаки лиц, извлеченные нейросетью
            user_ids (list): Список строковых ID пользователей, соответствующих кодировкам
        
        Примечание:
            Этот метод вызывается при запуске системы и при обновлении базы пользователей.
            Списки должны иметь одинаковую длину и быть синхронизированы по индексам.
        """
        self.registered_user_encodings = encodings
        self.registered_user_identifiers = user_ids
        
        # Логирование для отладки и мониторинга системы
        print(f"Загружено биометрических отпечатков: {len(self.registered_user_encodings)}")
    
    def generate_facial_encoding(self, image_path):
        """
        Создание биометрического отпечатка лица из фотографии
        
        Процесс создания кодировки включает несколько этапов:
        1. Загрузка изображения с диска через OpenCV
        2. Конвертация цветового пространства BGR → RGB  
        3. Детекция лиц на изображении с помощью детектора HOG
        4. Извлечение 128-мерного вектора признаков лица через CNN
        
        Алгоритм основан на модели ResNet, обученной на наборе данных лиц
        для создания устойчивых представлений, инвариантных к освещению,
        повороту и другим вариациям внешности.
        
        Аргументы:
            image_path (str): Полный путь к файлу изображения (JPEG, PNG, BMP)
            
        Возвращает:
            numpy.ndarray: 128-мерный вектор признаков лица (биометрический отпечаток)
            
        Исключения:
            Exception: Если изображение не найдено, повреждено или лицо не обнаружено
        """
        try:
            # Загрузка изображения с использованием OpenCV
            # OpenCV загружает изображения в формате BGR (Blue-Green-Red)
            image = cv2.imread(image_path)
            
            # Проверка успешности загрузки файла
            if image is None:
                raise Exception("Не удалось загрузить изображение. Проверьте путь к файлу и формат.")
            
            # Конвертация цветового пространства BGR → RGB
            # Библиотека face_recognition ожидает изображения в формате RGB
            rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
            
            # Извлечение биометрических признаков лица
            # face_recognition.face_encodings() использует:
            # 1. Детектор HOG для поиска лиц
            # 2. CNN для извлечения 128-мерного вектора признаков
            face_encodings = face_recognition.face_encodings(rgb_image)
            
            # Проверка, что на изображении обнаружено хотя бы одно лицо
            if face_encodings:
                # Возвращаем кодировку первого найденного лица
                # Если лиц несколько, берем первое (предполагаем одно лицо на фото регистрации)
                return face_encodings[0]
            else:
                raise Exception("Лицо не найдено на фотографии. Убедитесь, что лицо хорошо видно и не закрыто.")
                
        except Exception as e:
            # Перехват и обработка всех возможных ошибок с подробным описанием
            raise Exception(f"Ошибка создания биометрического отпечатка: {str(e)}")
    
    def detect_and_recognize_faces(self, frame, scale=0.25):
        """
        Обнаружение и распознавание лиц на видеокадре
        
        Комплексный алгоритм обработки видеокадра:
        1. Масштабирование кадра для ускорения обработки
        2. Детекция всех лиц на кадре с помощью детектора HOG
        3. Извлечение кодировок найденных лиц через CNN
        4. Векторизованное сравнение с базой зарегистрированных пользователей
        5. Определение наиболее похожего пользователя и вычисление уверенности
        
        Оптимизации производительности:
        - Масштабирование кадра (уменьшение в 4 раза ускоряет обработку в ~16 раз)
        - Векторизованные операции NumPy для параллельного сравнения
        - Ранний выход при отсутствии зарегистрированных пользователей
        
        Аргументы:
            frame (numpy.ndarray): Видеокадр в формате BGR от камеры
            scale (float): Коэффициент масштабирования (0.25 = 25% от исходного размера)
        
        Возвращает:
            list: Список словарей с информацией о каждом обнаруженном лице:
                {
                    'location': (top, right, bottom, left),  # Координаты прямоугольника лица
                    'confidence': float,                      # Уверенность распознавания (0-1)
                    'user_id': str или None,                 # ID распознанного пользователя
                    'is_known': bool                         # True если лицо распознано
                }
        """
        # Проверка наличия зарегистрированных пользователей в базе
        if not self.registered_user_encodings:
            return []  # Возвращаем пустой список если нет пользователей для сравнения
        
        # Масштабирование кадра для ускорения обработки
        # Пропорциональное уменьшение по осям X и Y
        small_frame = cv2.resize(frame, (0, 0), fx=scale, fy=scale)
        
        # Конвертация цветового пространства BGR → RGB для face_recognition
        rgb_small_frame = cv2.cvtColor(small_frame, cv2.COLOR_BGR2RGB)
        
        # Детекция лиц на уменьшенном кадре
        # Возвращает список координат прямоугольников с лицами в формате (top, right, bottom, left)
        face_locations = face_recognition.face_locations(rgb_small_frame)
        
        # Извлечение биометрических признаков для каждого найденного лица
        # face_encodings будет содержать 128-мерные векторы для каждого лица
        face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations)
        
        # Список для хранения результатов анализа каждого лица
        recognized_faces = []
        
        # Обработка каждого обнаруженного лица
        for face_encoding, face_location in zip(face_encodings, face_locations):
            
            # Векторизованное сравнение кодировки текущего лица со всеми зарегистрированными
            # Использует пороговое значение по умолчанию (0.6) для определения совпадений
            matches = face_recognition.compare_faces(self.registered_user_encodings, face_encoding)
            
            # Вычисление численных расстояний до каждого зарегистрированного лица
            # Евклидово расстояние в 128-мерном пространстве признаков
            # Меньшее расстояние означает большее сходство
            face_distances = face_recognition.face_distance(self.registered_user_encodings, face_encoding)
            
            # Поиск индекса наиболее похожего лица (минимальное расстояние)
            best_match_index = np.argmin(face_distances)
            
            # Преобразование расстояния в уверенность (0-1, где 1 = полное соответствие)
            confidence = 1 - face_distances[best_match_index]
            
            # Восстановление координат лица в исходном масштабе
            # Умножаем координаты на обратный коэффициент масштабирования
            top, right, bottom, left = face_location
            top = int(top / scale)
            right = int(right / scale)  
            bottom = int(bottom / scale)
            left = int(left / scale)
            
            # Создание структуры данных о распознанном лице
            recognized_face = {
                'location': (top, right, bottom, left),  # Координаты в исходном масштабе
                'confidence': confidence,                 # Численная уверенность
                'user_id': None,                         # По умолчанию - неизвестное лицо
                'is_known': False                        # Флаг распознанности
            }
            
            # Проверка двойного порога распознавания для повышения надежности
            # Лицо считается распознанным если:
            # 1. Есть совпадение в matches (базовый алгоритм сравнения)
            # 2. Уверенность выше настраиваемого порога из конфигурации
            if matches[best_match_index] and confidence > FACE_RECOGNITION_CONFIDENCE_THRESHOLD:
                recognized_face['user_id'] = self.registered_user_identifiers[best_match_index]
                recognized_face['is_known'] = True
            
            # Добавление результата в общий список
            recognized_faces.append(recognized_face)
        
        return recognized_faces
    
    def draw_detection_rectangle(self, frame, face_info, color, name=""):
        """
        Отрисовка прямоугольника вокруг обнаруженного лица с подписью
        
        Создает визуальную индикацию результатов распознавания:
        - Цветной прямоугольник вокруг лица (цвет кодирует статус)
        - Текстовая подпись с именем пользователя (если распознан)
        - Фоновый прямоугольник под текстом для улучшения читаемости
        
        Цветовая схема статусов:
        - Зеленый: Успешно распознанный пользователь
        - Красный: Неизвестное лицо
        - Желтый: Ожидание (защита от избыточных срабатываний)
        
        Аргументы:
            frame (numpy.ndarray): Видеокадр для отрисовки (изменяется на месте)
            face_info (dict): Информация о лице с координатами
            color (tuple): Цвет рамки в формате BGR (Blue, Green, Red)
            name (str): Имя пользователя для отображения (опционально)
        
        Возвращает:
            numpy.ndarray: Кадр с нарисованными элементами (тот же объект, что и входной)
        """
        # Извлечение координат прямоугольника лица
        top, right, bottom, left = face_info['location']
        
        # Отрисовка основного прямоугольника вокруг лица
        # Параметры: изображение, точка1, точка2, цвет_BGR, толщина_линии
        cv2.rectangle(frame, (left, top), (right, bottom), color, 2)
        
        # Отрисовка подписи с именем (если имя предоставлено)
        if name.strip():
            # Отрисовка фонового прямоугольника для текста
            # Размещается внизу основного прямоугольника лица
            cv2.rectangle(frame, (left, bottom - 35), (right, bottom), color, cv2.FILLED)
            
            # Отрисовка текста с именем пользователя
            # Параметры: изображение, текст, позиция, шрифт, размер, цвет, толщина
            cv2.putText(frame, name, (left + 6, bottom - 6), 
                       cv2.FONT_HERSHEY_DUPLEX, 0.6, (0, 0, 0), 1)
        
        return frame